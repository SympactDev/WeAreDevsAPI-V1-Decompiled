// Decompiled with JetBrains decompiler
// Type: WeAreDevs_API.ExploitAPI
// Assembly: WeAreDevs_API, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0B993892-EF4B-4CAC-9A08-23DCD2A22739
// Assembly location: C:\Users\flent\Downloads\WeAreDevs_API.dll

using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace WeAreDevs_API
{
  public class ExploitAPI
  {
    private WebClient client = new WebClient();
    private ExploitAPI.BasicInject injector = new ExploitAPI.BasicInject();
    private string cmdpipe = "WeAreDevsPublicAPI_CMD";
    private string luacpipe = "WeAreDevsPublicAPI_LuaC";
    private string luapipe = "WeAreDevsPublicAPI_Lua";

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool WaitNamedPipe(string name, int timeout);

    public static bool NamedPipeExist(string pipeName)
    {
      try
      {
        int timeout = 0;
        if (!ExploitAPI.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\.\\pipe\\{0}", (object) pipeName)), timeout))
        {
          switch (Marshal.GetLastWin32Error())
          {
            case 0:
              return false;
            case 2:
              return false;
          }
        }
        return true;
      }
      catch (Exception ex)
      {
        return false;
      }
    }

    private void SMTP(string pipe, string input)
    {
      if (ExploitAPI.NamedPipeExist(pipe))
      {
        try
        {
          using (NamedPipeClientStream pipeClientStream = new NamedPipeClientStream(".", pipe, PipeDirection.Out))
          {
            pipeClientStream.Connect();
            using (StreamWriter streamWriter = new StreamWriter((Stream) pipeClientStream))
            {
              streamWriter.Write(input);
              streamWriter.Dispose();
            }
            pipeClientStream.Dispose();
          }
        }
        catch (IOException ex)
        {
          int num = (int) MessageBox.Show("Error occured sending message to the game!", "Connection Failed!", MessageBoxButtons.OK, MessageBoxIcon.Hand);
        }
        catch (Exception ex)
        {
          int num = (int) MessageBox.Show(ex.Message.ToString());
        }
      }
      else
      {
        int num1 = (int) MessageBox.Show("Error occured. Did the dll properly inject?", "Oops", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
      }
    }

    private string ReadURL(string url) => this.client.DownloadString(url);

    private string GetLatestData()
    {
      string str1 = this.ReadURL("https://cdn.wearedevs.net/software/exploitapi/latestdata.txt");
      if (str1.Length > 0)
        return str1;
      string str2 = this.ReadURL("https://pastebin.com/raw/Ly9mJwH7");
      return str2.Length > 0 ? str2 : "";
    }

    public bool IsUpdated()
    {
      bool flag = false;
      string latestData = this.GetLatestData();
      if (latestData.Length > 0)
      {
        flag = Convert.ToBoolean(latestData.Split(' ')[0]);
      }
      else
      {
        int num = (int) MessageBox.Show("Could not check for the latest version. Did your fireall block us?", "Error");
      }
      return flag;
    }

    private bool DownloadLatestVersion()
    {
      if (System.IO.File.Exists("exploit-main.dll"))
        System.IO.File.Delete("exploit-main.dll");
      string latestData = this.GetLatestData();
      if (latestData.Length > 0)
        this.client.DownloadFile(latestData.Split(' ')[1], "exploit-main.dll");
      return System.IO.File.Exists("exploit-main.dll");
    }

    public bool isAPIAttached() => ExploitAPI.NamedPipeExist(this.cmdpipe);

    public bool LaunchExploit()
    {
      if (ExploitAPI.NamedPipeExist(this.cmdpipe))
      {
        int num1 = (int) MessageBox.Show("Dll already injected", "No problems");
      }
      else if (this.IsUpdated())
      {
        if (this.DownloadLatestVersion())
        {
          if (this.injector.InjectDLL())
            return true;
          int num2 = (int) MessageBox.Show("DLL failed to inject", "Error");
        }
        else
        {
          int num3 = (int) MessageBox.Show("Could not download the latest version! Did your firewall block us?", "Error");
        }
      }
      else
      {
        int num4 = (int) MessageBox.Show("Exploit is currently patched... Please wait for the developers to fix it! Meanwhile, check wearedevs.net for updates/info.", "Error");
      }
      return false;
    }

    public void SendCommand(string Command) => this.SMTP(this.cmdpipe, Command);

    [Obsolete("SendScript is deprecated, please use SendLuaCScript instead.")]
    public void SendScript(string script) => this.SendLuaCScript(script);

    public void SendLuaCScript(string Script)
    {
      foreach (string input in Script.Split("\r\n".ToCharArray()))
      {
        try
        {
          this.SMTP(this.luacpipe, input);
        }
        catch (Exception ex)
        {
          int num = (int) MessageBox.Show(ex.Message.ToString());
        }
      }
    }

    [Obsolete("SendLimitedLuaScript is deprecated, please use SendLuaScript instead.")]
    public void SendLimitedLuaScript(string script) => this.SendLuaScript(script);

    public void SendLuaScript(string Script) => this.SMTP(this.luapipe, Script);

    public void LuaC_getglobal(string service) => this.SendScript("getglobal " + service);

    public void LuaC_getfield(int index, string instance) => this.SendScript("getglobal " + index.ToString() + " " + instance);

    public void LuaC_setfield(int index, string property) => this.SendScript("setfield " + index.ToString() + " " + property);

    public void LuaC_pushvalue(int index) => this.SendScript("pushvalue " + index.ToString());

    public void LuaC_pushstring(string text) => this.SendScript("pushstring " + text);

    public void LuaC_pushnumber(int number) => this.SendScript("pushnumber " + number.ToString());

    public void LuaC_pcall(int numberOfArguments, int numberOfResults, int ErrorFunction) => this.SendScript("pushnumber " + numberOfArguments.ToString() + " " + numberOfResults.ToString() + " " + ErrorFunction.ToString());

    public void LuaC_settop(int index) => this.SendScript("settop " + index.ToString());

    public void LuaC_pushboolean(string value = "false") => this.SendScript("pushboolean " + value);

    public void LuaC_gettop() => this.SendScript("gettop");

    public void LuaC_pushnil() => this.SendScript("pushnil");

    public void LuaC_next(int index) => this.SendScript("next");

    public void LuaC_pop(int quantity) => this.SendScript("pop " + quantity.ToString());

    public void DoBTools(string username = "me") => this.SendCommand("btools " + username);

    public void DoKill(string username = "me") => this.SendCommand("kill " + username);

    public void CreateForceField(string username = "me") => this.SendCommand("ff " + username);

    public void RemoveForceField(string username = "me") => this.SendCommand("noff " + username);

    public void DoFloat(string username = "me") => this.SendCommand("float " + username);

    public void DoNoFloat(string username = "me") => this.SendCommand("nofloat " + username);

    public void RemoveLimbs(string username = "me") => this.SendCommand("nolimbs " + username);

    public void RemoveArms(string username = "me") => this.SendCommand("noarms " + username);

    public void RemoveLegs(string username = "me") => this.SendCommand("nolegs " + username);

    public void AddFire(string username = "me") => this.SendCommand("fire " + username);

    public void RemoveFire(string username = "me") => this.SendCommand("nofire " + username);

    public void AddSparkles(string username = "me") => this.SendCommand("sparkles " + username);

    public void RemoveSparkles(string username = "me") => this.SendCommand("nosparkles " + username);

    public void AddSmoke(string username = "me") => this.SendCommand("smoke " + username);

    public void DoBlockHead(string username = "me") => this.SendCommand("blockhead " + username);

    public void ForceBubbleChat(string username = "me", string text = "WeAreDevs Website") => this.SendCommand("chat " + username + " " + text);

    public void ConsolePrint(string text = "WeAreDevs Website") => this.SendCommand("print " + text);

    public void ConsoleWarn(string text = "meWeAreDevs Website") => this.SendCommand("warn " + text);

    public void SetWalkSpeed(string username = "me", int value = 100) => this.SendCommand("speed " + username + " " + value.ToString());

    public void ToggleClickTeleport() => this.SendCommand("toggleclickteleport");

    public void SetFogEnd(int value = 0) => this.SendCommand("fogend " + value.ToString());

    public void SetJumpPower(int value = 100) => this.SendCommand("jumppower " + value.ToString());

    public void TeleportMyCharacterTo(string target_username = "me") => this.SendCommand("teleport " + target_username);

    public void PlaySoundInGame(string assetid = "1071384374") => this.SendCommand("music " + assetid);

    public void SetSkyboxImage(string assetid = "2143522") => this.SendCommand("skybox " + assetid);

    private class BasicInject
    {
      [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
      internal static extern IntPtr LoadLibraryA(string lpFileName);

      [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
      internal static extern UIntPtr GetProcAddress(IntPtr hModule, string procName);

      [DllImport("kernel32.dll", SetLastError = true)]
      [return: MarshalAs(UnmanagedType.Bool)]
      internal static extern bool FreeLibrary(IntPtr hModule);

      [DllImport("kernel32.dll")]
      internal static extern IntPtr OpenProcess(
        ExploitAPI.BasicInject.ProcessAccess dwDesiredAccess,
        [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,
        int dwProcessId);

      [DllImport("kernel32.dll", SetLastError = true)]
      internal static extern IntPtr VirtualAllocEx(
        IntPtr hProcess,
        IntPtr lpAddress,
        uint dwSize,
        uint flAllocationType,
        uint flProtect);

      [DllImport("kernel32.dll", SetLastError = true)]
      internal static extern bool WriteProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        byte[] lpBuffer,
        uint nSize,
        out UIntPtr lpNumberOfBytesWritten);

      [DllImport("kernel32.dll")]
      internal static extern IntPtr CreateRemoteThread(
        IntPtr hProcess,
        IntPtr lpThreadAttributes,
        uint dwStackSize,
        UIntPtr lpStartAddress,
        IntPtr lpParameter,
        uint dwCreationFlags,
        out IntPtr lpThreadId);

      [DllImport("kernel32.dll", SetLastError = true)]
      internal static extern bool ReadProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        [Out] byte[] lpBuffer,
        int dwSize,
        out int lpNumberOfBytesRead);

      public bool InjectDLL()
      {
        if (Process.GetProcessesByName("RobloxPlayerBeta").Length == 0)
          return false;
        Process process = Process.GetProcessesByName("RobloxPlayerBeta")[0];
        byte[] bytes = new ASCIIEncoding().GetBytes(AppDomain.CurrentDomain.BaseDirectory + "exploit-main.dll");
        IntPtr hModule = ExploitAPI.BasicInject.LoadLibraryA("kernel32.dll");
        UIntPtr procAddress = ExploitAPI.BasicInject.GetProcAddress(hModule, "LoadLibraryA");
        ExploitAPI.BasicInject.FreeLibrary(hModule);
        if (procAddress == UIntPtr.Zero)
          return false;
        IntPtr hProcess = ExploitAPI.BasicInject.OpenProcess(ExploitAPI.BasicInject.ProcessAccess.AllAccess, false, process.Id);
        if (hProcess == IntPtr.Zero)
          return false;
        IntPtr num = ExploitAPI.BasicInject.VirtualAllocEx(hProcess, (IntPtr) 0, (uint) bytes.Length, 12288U, 4U);
        return !(num == IntPtr.Zero) && ExploitAPI.BasicInject.WriteProcessMemory(hProcess, num, bytes, (uint) bytes.Length, out UIntPtr _) && !(ExploitAPI.BasicInject.CreateRemoteThread(hProcess, (IntPtr) 0, 0U, procAddress, num, 0U, out IntPtr _) == IntPtr.Zero);
      }

      [System.Flags]
      public enum ProcessAccess
      {
        AllAccess = 1050235, // 0x0010067B
        CreateThread = 2,
        DuplicateHandle = 64, // 0x00000040
        QueryInformation = 1024, // 0x00000400
        SetInformation = 512, // 0x00000200
        Terminate = 1,
        VMOperation = 8,
        VMRead = 16, // 0x00000010
        VMWrite = 32, // 0x00000020
        Synchronize = 1048576, // 0x00100000
      }
    }
  }
}
